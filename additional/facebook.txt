(1) http://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=115321&extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26searchoption[3046][value][2]%3D2%26searchoption[3046][type]%3Dcheckbox%26sortid%3D311

(I) Celebrity problem:
You have a room with n people. A celebrity walks in. Everyone knows the celebrity, the celebrity knows no one. 
Non-celebrities may/may not know anyone in the room. Give an algorithm to find the celebrity. Discuss the complexity.

-->
The solution is O(n) in time complexity.

Make all of them stand in a row.
Lets say the people are a,b,c,d,e,f,g,h,i,j,.......n

Compare a and b.
if a knows b => a is certainly not the celebrity. Probable celebrity = b
if a doesnt know b => b is certainly not the celebrity. Probable celebrity = a

In either case compare the probable celebrity to the next person in line ie 'c' and repeat the process. 
Each comparison should eliminate 1 person and have another as the probable celebrity. 
At the end, the probable celebrity who survives is the certain celebrity.

If a and b dont know each other, they both will eventually get eliminated

Complexity = O(n)

(||)给一个double array, 返回一个新的array, 每个元素是原来的array除它之外所有元素的乘积。
--> 先写了用除法的，然后问不用除法怎么做

(2) http://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=97532&extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26searchoption[3046][value][2]%3D2%26searchoption[3046][type]%3Dcheckbox%26sortid%3D311

find the interection of two BST.
Print the number that appear in both BST
No extra space, must be linear time

--> 先flatten BST to linkedlist(这个也不用额外开辟新的list内存)，然后你比较两个list的相交部分

(3) http://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=111427&extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26searchoption[3046][value][2]%3D2%26searchoption[3046][type]%3Dcheckbox%26sortid%3D311

题真是简单的没话说，给了两个sorted array，让你求这两个array的intersection。题目的难点在三哥的口音上，其他没啥。
然后问了问时间空间复杂度。我说时间复杂度O(n),n是长的那个数组的长度。他非要说是O(m+n)，我说这不没啥区别么，
但他说我想要的是这个答案。

follow up说是一个数组比较短，另一个很长，问你怎么改进。我说用二分法先查到短的数组的min和max都是在长数组的什么位置，
这样先把搜索区间减少一点；他说那玩意这个区间就正好还是长数组的长度，这不就没有改进了么。我纠结了一两分钟说能给点
提示不。他说你不要管第一个数组是sorted这个条件，就当他是乱序的。我说那就把短数组每个元素都在长数组里binary search
一次好了，复杂度O(mlogn)。他说对我就是要这个答案。。。然后把二分搜索的代码写了一下，
然后又用一个实例比较了一下这两种方法的复杂度。

(4) http://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=110360&extra=page%3D2%26filter%3Dsortid%26sortid%3D311%26searchoption[3046][value][2]%3D2%26searchoption[3046][type]%3Dcheckbox%26sortid%3D311

题目很简单，double sqrt(double x)，连这个二分都写了一个bug，真想抽死自己。。二分写完后，面试官问能不能更快，
我说那每次分成三个区间，缩小成原来的1/3，他说这个解法很interesting，但不是他想要的，如果一开始x是一个特别大的数，
比如几个billion，应该如何一开始比较快地缩小范围，完全不知道怎么做= =
还有经典的2sum。。follow up问如果是浮点数，hash的时候会有什么问题，我说精度可能有问题（其实不是很懂。。），
他说了一堆没他听清。。问怎么hash浮点数，我说乘以一个很大的整数，比如1 million之类的，转化为整数再去hash，他说可以。

如果x很大的话， 我们是否可以用2^k来估计一下sqrt的范围。即先找到最大的k 使得 2^{2k} < x <= 2^{2(k + 1)}
然后在【2^k ,2^{k +1}】内做2分？
如果是float number的话，我们是否可以做两个hashing： hashing 整数部分 和hashing小数部分？求牛人指点一下。
